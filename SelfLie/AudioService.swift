import AVFoundation
import Foundation

@Observable
class AudioService: NSObject {
    private var audioRecorder: AVAudioRecorder?
    private var audioPlayer: AVAudioPlayer?
    private var preparedRecorder: AVAudioRecorder?
    private var preWarmedTimer: Timer?
    
    // Helper function to get hardware-compatible audio settings
    private func getAudioSettings() -> [String: Any] {
        let audioSession = AVAudioSession.sharedInstance()
        let hardwareSampleRate = audioSession.sampleRate
        
        print("üéôÔ∏è [AudioService] Using hardware sample rate: \(hardwareSampleRate) Hz")
        
        return [
            AVFormatIDKey: kAudioFormatMPEG4AAC,
            AVSampleRateKey: hardwareSampleRate, // Use hardware sample rate
            AVNumberOfChannelsKey: 1,
            AVEncoderAudioQualityKey: AVAudioQuality.high.rawValue
        ]
    }
    
    var isRecording = false
    var isPlaying = false
    var recordingDuration: TimeInterval = 0
    
    private var recordingTimer: Timer?
    private var playbackProgressTimer: Timer?
    
    // Êí≠ÊîæÂÆåÊàêÊ£ÄÊµã‰ºòÂåñÔºö‰ΩøÁî®ContinuationÊõø‰ª£ËΩÆËØ¢
    private var playbackCompletionContinuation: CheckedContinuation<Void, Error>?
    
    // Playback progress callbacks
    var onPlaybackProgress: ((TimeInterval, TimeInterval) -> Void)?
    var onPlaybackComplete: (() -> Void)?
    
    override init() {
        super.init()
        // Audio session is now managed by AudioSessionManager
    }
    
    deinit {
        recordingTimer?.invalidate()
        preWarmedTimer?.invalidate()
        playbackProgressTimer?.invalidate()
        cleanupPreparedRecording()
        
        // Ê∏ÖÁêÜÊí≠ÊîæÂÆåÊàêcontinuation
        playbackCompletionContinuation?.resume(throwing: CancellationError())
        playbackCompletionContinuation = nil
    }
    
    func requestMicrophonePermission() async -> Bool {
        await withCheckedContinuation { continuation in
            AVAudioApplication.requestRecordPermission { granted in
                continuation.resume(returning: granted)
            }
        }
    }
    
    func prepareRecording(to url: URL) async throws {
        guard preparedRecorder == nil else { return }
        
        print("‚è∞ [AudioService] üîß prepareRecording() started")
        let prepareStartTime = Date()
        
        // Ensure directory exists
        let directoryStartTime = Date()
        let directory = url.deletingLastPathComponent()
        try FileManager.default.createDirectory(at: directory, withIntermediateDirectories: true, attributes: nil)
        let directoryDuration = Date().timeIntervalSince(directoryStartTime) * 1000
        print("‚è∞ [AudioService] üìÅ Directory creation in \(String(format: "%.0fms", directoryDuration))")
        
        let settings = getAudioSettings()
        
        do {
            // Create recorder
            let recorderCreateStartTime = Date()
            preparedRecorder = try AVAudioRecorder(url: url, settings: settings)
            preparedRecorder?.delegate = self
            let recorderCreateDuration = Date().timeIntervalSince(recorderCreateStartTime) * 1000
            print("‚è∞ [AudioService] üéôÔ∏è AVAudioRecorder created in \(String(format: "%.0fms", recorderCreateDuration))")
            
            // Aggressively prepare recorder
            let prepareToRecordStartTime = Date()
            preparedRecorder?.prepareToRecord()
            let prepareToRecordDuration = Date().timeIntervalSince(prepareToRecordStartTime) * 1000
            print("‚è∞ [AudioService] ‚ö° prepareToRecord() completed in \(String(format: "%.0fms", prepareToRecordDuration))")
            
            // Pre-warm the timer to eliminate timer creation delay later
            let timerWarmupStartTime = Date()
            preWarmedTimer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { _ in
                // This timer will be transferred to recordingTimer when recording starts
                // For now, it does nothing but stays warm
            }
            // Immediately invalidate and keep it ready for transfer
            preWarmedTimer?.invalidate()
            preWarmedTimer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { _ in
                self.recordingDuration = self.audioRecorder?.currentTime ?? 0
            }
            // Keep it paused until we need it
            preWarmedTimer?.invalidate()
            preWarmedTimer = nil // Will recreate when needed
            let timerWarmupDuration = Date().timeIntervalSince(timerWarmupStartTime) * 1000
            print("‚è∞ [AudioService] ‚è±Ô∏è Timer warmup completed in \(String(format: "%.0fms", timerWarmupDuration))")
            
            let totalPrepareDuration = Date().timeIntervalSince(prepareStartTime) * 1000
            print("‚è∞ [AudioService] ‚úÖ prepareRecording() completed in \(String(format: "%.0fms", totalPrepareDuration))")
        } catch {
            preparedRecorder = nil
            print("‚è∞ [AudioService] ‚ùå prepareRecording() failed: \(error.localizedDescription)")
            throw AudioServiceError.recordingFailed
        }
    }
    
    func startPreparedRecording() async throws {
        print("‚è∞ [AudioService] üöÄ startPreparedRecording() entered")
        let startTime = Date()
        
        guard !isRecording else { 
            print("‚è∞ [AudioService] ‚ö†Ô∏è Already recording, returning")
            return 
        }
        guard let preparedRecorder = preparedRecorder else {
            print("‚è∞ [AudioService] ‚ùå No prepared recorder available")
            throw AudioServiceError.recordingFailed
        }
        
        // Audio session is already configured for .playAndRecord in AudioSessionManager.init()
        // No need to switch - just ensure it's active
        try await AudioSessionManager.shared.ensureSessionActive()
        
        // Ultra-fast recording start: minimize operations
        let recordStartTime = Date()
        
        // Atomic state update and recorder transfer
        isRecording = true
        recordingDuration = 0
        audioRecorder = preparedRecorder
        self.preparedRecorder = nil
        
        // Start recording immediately - this should be instantaneous since recorder is fully prepared
        audioRecorder?.record()
        
        let recordDuration = Date().timeIntervalSince(recordStartTime) * 1000
        print("‚è∞ [AudioService] ‚ö° Ultra-fast record() completed in \(String(format: "%.0fms", recordDuration))")
        
        // Use pre-warmed timer if available, otherwise create new one
        if let existingTimer = preWarmedTimer {
            print("‚è∞ [AudioService] üî• Using pre-warmed timer")
            recordingTimer = existingTimer
            preWarmedTimer = nil
        } else {
            let timerStartTime = Date()
            recordingTimer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { _ in
                self.recordingDuration = self.audioRecorder?.currentTime ?? 0
            }
            let timerDuration = Date().timeIntervalSince(timerStartTime) * 1000
            print("‚è∞ [AudioService] ‚è±Ô∏è New timer created in \(String(format: "%.0fms", timerDuration))")
        }
        
        let totalDuration = Date().timeIntervalSince(startTime) * 1000
        print("‚è∞ [AudioService] ‚úÖ startPreparedRecording() completed in \(String(format: "%.0fms", totalDuration))")
    }
    
    func startRecording(to url: URL) async throws {
        guard !isRecording else { return }
        
        // Ensure directory exists
        let directory = url.deletingLastPathComponent()
        try FileManager.default.createDirectory(at: directory, withIntermediateDirectories: true, attributes: nil)
        
        let settings = getAudioSettings()
        
        do {
            audioRecorder = try AVAudioRecorder(url: url, settings: settings)
            audioRecorder?.delegate = self
            audioRecorder?.prepareToRecord()
            audioRecorder?.record()
            
            isRecording = true
            recordingDuration = 0
            
            // Start timer for duration tracking
            recordingTimer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { _ in
                self.recordingDuration = self.audioRecorder?.currentTime ?? 0
            }
        } catch {
            throw AudioServiceError.recordingFailed
        }
    }
    
    func cleanupPreparedRecording() {
        preparedRecorder = nil
        preWarmedTimer?.invalidate()
        preWarmedTimer = nil
    }
    
    func stopRecording() {
        guard isRecording else { return }
        
        audioRecorder?.stop()
        audioRecorder = nil
        isRecording = false
        
        recordingTimer?.invalidate()
        recordingTimer = nil
    }
    
    func playAudio(from url: URL) async throws {
        print("‚è∞ [AudioService] üéµ playAudio() method entered")
        guard !isPlaying else { 
            print("‚è∞ [AudioService] ‚ö†Ô∏è Already playing, returning early")
            return 
        }
        
        // Audio session is already configured for .playAndRecord in AudioSessionManager.init()
        // No need to switch - just ensure it's active
        try await AudioSessionManager.shared.ensureSessionActive()
        
        do {
            print("‚è∞ [AudioService] üîß Creating AVAudioPlayer")
            let playerCreateStartTime = Date()
            audioPlayer = try AVAudioPlayer(contentsOf: url)
            audioPlayer?.delegate = self
            audioPlayer?.prepareToPlay()
            let playerCreateDuration = Date().timeIntervalSince(playerCreateStartTime) * 1000
            print("‚è∞ [AudioService] ‚úÖ AVAudioPlayer created and prepared in \(String(format: "%.0fms", playerCreateDuration))")
            
            isPlaying = true
            
            // Start progress tracking timer
            startPlaybackProgressTracking()
            
            print("‚è∞ [AudioService] ‚ñ∂Ô∏è Calling audioPlayer.play()")
            let playStartTime = Date()
            audioPlayer?.play()
            let playCallDuration = Date().timeIntervalSince(playStartTime) * 1000
            print("‚è∞ [AudioService] ‚úÖ audioPlayer.play() call completed in \(String(format: "%.0fms", playCallDuration))")
            
            // ‰ºòÂåñÔºö‰ΩøÁî®ContinuationÁ≠âÂæÖÊí≠ÊîæÂÆåÊàêÔºåÊõø‰ª£ËΩÆËØ¢
            print("‚è∞ [AudioService] ‚è≥ Waiting for playback completion via delegate callback")
            let waitStartTime = Date()
            
            // ‰ΩøÁî®continuationÁ≠âÂæÖAVAudioPlayerDelegateÂõûË∞É
            try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
                // Á°Æ‰øùÊ≤°Êúâ‰πãÂâçÁöÑcontinuationÊÆãÁïô
                if let oldContinuation = playbackCompletionContinuation {
                    oldContinuation.resume(throwing: CancellationError())
                }
                playbackCompletionContinuation = continuation
                
                // Á´ãÂç≥Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÊí≠ÊîæÂÆåÊàêÔºàÈò≤Ê≠¢Á´ûÊÄÅÊù°‰ª∂Ôºâ
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.01) {
                    if self.audioPlayer?.isPlaying == false {
                        // Â∑≤ÁªèÂÆåÊàêÊí≠ÊîæÔºåÁ´ãÂç≥Ëß¶Âèë
                        if let cont = self.playbackCompletionContinuation {
                            self.playbackCompletionContinuation = nil
                            cont.resume()
                        }
                    }
                }
            }
            
            let totalWaitDuration = Date().timeIntervalSince(waitStartTime) * 1000
            print("‚è∞ [AudioService] ‚úÖ Playback completed via delegate callback after \(String(format: "%.0fms", totalWaitDuration))")
            
            // Stop progress tracking
            stopPlaybackProgressTracking()
            
            // Notify completion
            onPlaybackComplete?()
            
            // Keep audio session active for subsequent recording operations
            print("‚è∞ [AudioService] üéµ Playback completed, keeping audio session active for recording")
            
        } catch {
            print("‚è∞ [AudioService] ‚ùå playAudio() failed with error: \(error.localizedDescription)")
            isPlaying = false
            stopPlaybackProgressTracking()
            
            // Ê∏ÖÁêÜÊí≠ÊîæÂÆåÊàêcontinuation
            if let continuation = playbackCompletionContinuation {
                playbackCompletionContinuation = nil
                continuation.resume(throwing: error)
            }
            
            // Keep audio session active even on failure, will be deactivated when PracticeView closes
            print("‚è∞ [AudioService] ‚ö†Ô∏è Playback failed, keeping audio session active for cleanup by caller")
            
            throw AudioServiceError.playbackFailed
        }
        
        print("‚è∞ [AudioService] üéµ playAudio() method exiting")
    }
    
    func stopPlayback() {
        audioPlayer?.stop()
        audioPlayer = nil
        isPlaying = false
        stopPlaybackProgressTracking()
        
        // Ê∏ÖÁêÜÊí≠ÊîæÂÆåÊàêcontinuation
        if let continuation = playbackCompletionContinuation {
            playbackCompletionContinuation = nil
            continuation.resume(throwing: CancellationError())
        }
    }
    
    private func startPlaybackProgressTracking() {
        stopPlaybackProgressTracking() // Stop any existing timer
        
        print("üéµ [AudioService] Starting playback progress tracking")
        
        // Ensure timer runs on main queue for UI updates
        DispatchQueue.main.async { [weak self] in
            guard let self = self else { return }
            
            self.playbackProgressTimer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { [weak self] _ in
                guard let self = self,
                      let player = self.audioPlayer else { 
                    print("üéµ [AudioService] ‚ö†Ô∏è Progress tracking callback: no player available")
                    return 
                }
                
                let currentTime = player.currentTime
                let duration = player.duration
                
                // ÊØèÁßíÂè™ÊâìÂç∞‰∏ÄÊ¨°ËøõÂ∫¶Êó•ÂøóÔºåÂáèÂ∞ëÂô™Èü≥
                if Int(currentTime) != Int(currentTime - 0.1) {
                    print("üéµ [AudioService] Progress: \(String(format: "%.1f", currentTime))/\(String(format: "%.1f", duration))s")
                }
                
                if let callback = self.onPlaybackProgress {
                    callback(currentTime, duration)
                    // Note: Removed frequent callback success log to reduce noise
                }
                // Note: Removed missing callback warning as it may occur normally during replay
            }
            
            // Add timer to main run loop
            RunLoop.main.add(self.playbackProgressTimer!, forMode: .common)
        }
    }
    
    private func stopPlaybackProgressTracking() {
        DispatchQueue.main.async { [weak self] in
            self?.playbackProgressTimer?.invalidate()
            self?.playbackProgressTimer = nil
            print("üéµ [AudioService] Stopped playback progress tracking")
        }
    }
}

extension AudioService: AVAudioRecorderDelegate {
    func audioRecorderDidFinishRecording(_ recorder: AVAudioRecorder, successfully flag: Bool) {
        isRecording = false
        recordingTimer?.invalidate()
        recordingTimer = nil
    }
}

extension AudioService: AVAudioPlayerDelegate {
    func audioPlayerDidFinishPlaying(_ player: AVAudioPlayer, successfully flag: Bool) {
        print("‚è∞ [AudioService] üéµ AVAudioPlayerDelegate: playback finished successfully=\(flag)")
        isPlaying = false
        audioPlayer = nil
        
        // Á´ãÂç≥ÈÄöËøácontinuationËß¶ÂèëÊí≠ÊîæÂÆåÊàê
        if let continuation = playbackCompletionContinuation {
            playbackCompletionContinuation = nil
            if flag {
                continuation.resume()
            } else {
                continuation.resume(throwing: AudioServiceError.playbackFailed)
            }
        }
    }
}

enum AudioServiceError: LocalizedError {
    case recordingFailed
    case playbackFailed
    case permissionDenied
    
    var errorDescription: String? {
        switch self {
        case .recordingFailed:
            return "Failed to start recording"
        case .playbackFailed:
            return "Failed to play audio"
        case .permissionDenied:
            return "Microphone permission denied"
        }
    }
}

// MARK: - Audio Session Manager

@Observable
class AudioSessionManager {
    static let shared = AudioSessionManager()
    
    private let audioSession = AVAudioSession.sharedInstance()
    private var recordingWarmupRecorder: AVAudioRecorder?
    private var initializationError: Error?
    
    private init() {
        setupAudioSession()
    }
    
    private func setupAudioSession() {
        do {
            // Ê£ÄÊµãËìùÁâôËÆæÂ§áËøûÊé•Áä∂ÊÄÅÔºåÂä®ÊÄÅÈÄâÊã©Èü≥È¢ëÈÄâÈ°π‰ª•ÈÅøÂÖçÂÜ≤Á™Å
            let hasBluetoothDevice = isBluetoothAudioDeviceConnected()
            let audioOptions: AVAudioSession.CategoryOptions = hasBluetoothDevice 
                ? [.allowBluetoothA2DP] // ËìùÁâôËÆæÂ§áÔºö‰ªÖÂÖÅËÆ∏A2DPÈ´òË¥®ÈáèÈü≥È¢ë
                : [.defaultToSpeaker]   // Êó†ËìùÁâôËÆæÂ§áÔºöÈªòËÆ§‰ΩøÁî®Êâ¨Â£∞Âô®
            
            try audioSession.setCategory(.playAndRecord, mode: .default, options: audioOptions)
            try audioSession.setActive(true)
            
            let deviceType = hasBluetoothDevice ? "Bluetooth A2DP" : "Phone Speaker"
            print("‚úÖ [AudioSessionManager] Audio session initialized for \(deviceType)")
            initializationError = nil // Ê∏ÖÈô§‰ªª‰Ωï‰πãÂâçÁöÑÈîôËØØ
        } catch {
            initializationError = error
            print("‚ùå [AudioSessionManager] Failed to initialize audio session: \(error.localizedDescription)")
        }
    }
    
    // Issue 1 Fix: AirPods audio routing support
    func isBluetoothAudioDeviceConnected() -> Bool {
        let route = AVAudioSession.sharedInstance().currentRoute
        let hasBluetoothOutput = route.outputs.contains { output in
            output.portType == .bluetoothA2DP || 
            output.portType == .bluetoothHFP ||
            output.portType == .bluetoothLE
        }
        
        let hasBluetoothInput = route.inputs.contains { input in
            input.portType == .bluetoothHFP ||
            input.portType == .bluetoothLE
        }
        
        let result = hasBluetoothOutput || hasBluetoothInput
        
        // Enhanced logging for debugging
        print("üéß [AudioSessionManager] Bluetooth detection:")
        print("   Current route: \(route)")
        print("   Outputs: \(route.outputs.map { "\($0.portName) (\($0.portType.rawValue))" })")
        print("   Inputs: \(route.inputs.map { "\($0.portName) (\($0.portType.rawValue))" })")
        print("   Has Bluetooth Output: \(hasBluetoothOutput)")
        print("   Has Bluetooth Input: \(hasBluetoothInput)")
        print("   Final Result: \(result)")
        
        return result
    }
    
    func getAudioSessionOptions(hasBluetoothDevice: Bool) -> AVAudioSession.CategoryOptions {
        if hasBluetoothDevice {
            // For AirPods and Bluetooth devices: allow Bluetooth A2DP, interrupt other audio apps
            return [.allowBluetoothA2DP]
        } else {
            // For phone speaker: default to speaker, interrupt other audio apps
            return [.defaultToSpeaker]
        }
    }
    
    /// Ensure the audio session is active (session is already configured in init)
    func ensureSessionActive() async throws {

        // È¶ñÂÖàÊ£ÄÊü•ÂàùÂßãÂåñÊòØÂê¶ÊàêÂäü
        if let initError = initializationError {
            print("‚ùå [AudioSessionManager] Cannot ensure session active due to initialization failure")
            throw initError
        }
        
        // Ê£ÄÊü•‰ºöËØùÊòØÂê¶Â∑≤ÁªèÊøÄÊ¥ªÔºåÈÅøÂÖçÈáçÂ§çÊìç‰Ωú
        if audioSession.isOtherAudioPlaying == false && audioSession.secondaryAudioShouldBeSilencedHint == false {
            // ‰ºöËØùÂèØËÉΩÂ∑≤ÁªèÊøÄÊ¥ªÔºåÂÖàÊ£ÄÊü•Áä∂ÊÄÅ
            do {
                // Âè™Âú®ÈúÄË¶ÅÊó∂ÊâçÈáçÊñ∞ÊøÄÊ¥ª
                try audioSession.setActive(true)
                print("‚úÖ [AudioSessionManager] Audio session activated successfully")
            } catch {
                print("‚ùå [AudioSessionManager] Failed to activate audio session: \(error.localizedDescription)")
                throw error
            }
        } else {
            print("‚úÖ [AudioSessionManager] Audio session already active")
        }
    }
    
    
    
    
    // forceAudioRoutingÊñπÊ≥ïÂ∑≤ÁßªÈô§ - Á≥ªÁªü‰ºöËá™Âä®Â§ÑÁêÜÈü≥È¢ëË∑ØÁî±
    
    func preWarmRecording(to url: URL) async throws {
        print("‚è∞ [AudioSessionManager] üî• Pre-warming recording (optimized)")
        let warmupStartTime = Date()
        
        // Verify current audio session compatibility with recording
        let currentCategory = audioSession.category
        if currentCategory != .playAndRecord && currentCategory != .record {
            print("‚è∞ [AudioSessionManager] ‚ö†Ô∏è Current session (\(currentCategory)) may not support recording warmup")
            print("‚è∞ [AudioSessionManager] üìù Warmup will proceed but may have limited effectiveness")
        }
        
        // Optimized warmup: skip actual file recording, just prepare the audio system
        // Note: No audio session change needed during warmup - keep current session
        let systemWarmupStartTime = Date()
        
        // Create minimal warmup without file I/O
        // Use hardware-compatible sample rate
        let audioSession = AVAudioSession.sharedInstance()
        let hardwareSampleRate = audioSession.sampleRate
        
        let settings: [String: Any] = [
            AVFormatIDKey: kAudioFormatMPEG4AAC,
            AVSampleRateKey: hardwareSampleRate, // Use hardware sample rate
            AVNumberOfChannelsKey: 1,
            AVEncoderAudioQualityKey: AVAudioQuality.high.rawValue
        ]
        
        print("üéôÔ∏è [AudioSessionManager] Using hardware sample rate: \(hardwareSampleRate) Hz")
        
        do {
            // Use in-memory URL for super-fast warmup
            let tempURL = URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent("warmup_\(UUID().uuidString).m4a")
            
            recordingWarmupRecorder = try AVAudioRecorder(url: tempURL, settings: settings)
            recordingWarmupRecorder?.prepareToRecord()
            
            // Micro-burst recording to warm up audio stack without file overhead
            recordingWarmupRecorder?.record()
            
            // Use Task.sleep for precise timing control
            try await Task.sleep(nanoseconds: 5_000_000) // 5ms micro-burst
            
            recordingWarmupRecorder?.stop()
            recordingWarmupRecorder = nil
            
            // Clean up warmup file immediately
            try? FileManager.default.removeItem(at: tempURL)
            
            let systemWarmupDuration = Date().timeIntervalSince(systemWarmupStartTime) * 1000
            print("‚è∞ [AudioSessionManager] ‚ö° Audio system warmed in \(String(format: "%.0fms", systemWarmupDuration))")
            
        } catch {
            let systemWarmupDuration = Date().timeIntervalSince(systemWarmupStartTime) * 1000
            print("‚è∞ [AudioSessionManager] ‚ö†Ô∏è Audio system warmup failed in \(String(format: "%.0fms", systemWarmupDuration)): \(error.localizedDescription)")
            // Don't throw - warmup failure shouldn't block the main flow
        }
        
        let totalWarmupDuration = Date().timeIntervalSince(warmupStartTime) * 1000
        print("‚è∞ [AudioSessionManager] ‚úÖ Complete recording pre-warmup in \(String(format: "%.0fms", totalWarmupDuration))")
    }
    
    enum AudioMode {
        case playback
        case recording
        case playAndRecord
    }
    
    func resetAudioSession(to mode: AudioMode = .playback) async throws {
        print("‚è∞ [AudioSessionManager] üîÑ Resetting audio session to \(mode)")
        
        recordingWarmupRecorder?.stop()
        recordingWarmupRecorder = nil
        
        try audioSession.setActive(false)
        try await Task.sleep(nanoseconds: 100_000_000) // 0.1 second delay
        
        // ÈáçÊñ∞ËÆæÁΩÆ‰∏∫.playAndRecordÔºà‰∏éÂàùÂßãÂåñÁõ∏ÂêåÔºâ
        do {
            try audioSession.setCategory(.playAndRecord, mode: .default, options: [.allowBluetoothA2DP, .defaultToSpeaker])
            try audioSession.setActive(true)
            print("‚úÖ [AudioSessionManager] Audio session reset to .playAndRecord")
        } catch {
            print("‚ùå [AudioSessionManager] Failed to reset audio session: \(error.localizedDescription)")
            throw error
        }
        
        print("‚è∞ [AudioSessionManager] ‚úÖ Audio session reset to \(mode) completed")
    }
    
    func deactivateSession() async throws {
        print("‚è∞ [AudioSessionManager] üîÑ Deactivating audio session and notifying other apps")
        try audioSession.setActive(false, options: .notifyOthersOnDeactivation)
        print("‚è∞ [AudioSessionManager] ‚úÖ Audio session deactivated successfully")
    }
}
